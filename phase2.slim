// Phase 2: Introduce inversion from burn-in state
// Run independent replicates to capture cases where inversion persists

initialize() {

    // Parameters
    defineConstant("K_ANCESTRAL", 5000);
    defineConstant("L", 23e6);
    defineConstant("REC_RATE", 2e-8);
    defineConstant("INV_START", 2e6);
    defineConstant("INV_END", 13e6);
    defineConstant("MU_DELETERIOUS", 1e-8);
    defineConstant("DFE_SHAPE", 0.2);
    defineConstant("DFE_MEAN_S", -0.04);
    defineConstant("H_DOMINANCE", 0.0);
    defineConstant("INV_TRACKING_GENS", 10 * K_ANCESTRAL);
    defineConstant("LOG_INTERVAL", 1000);

    if (!exists("jobID")) defineConstant("jobID", 1);

    // Model setup
    initializeSLiMModelType("WF");

    // Deleterious mutation
    initializeMutationType("m2", H_DOMINANCE, "g",
                           DFE_MEAN_S, DFE_SHAPE);
    m2.convertToSubstitution = F;

    // Inversion marker
    initializeMutationType("m3", 0.5, "f", 0.0);
    m3.convertToSubstitution = F;

    defineConstant("INV_MARKER_POS",
                   integerDiv(INV_START + INV_END, 2));

    initializeGenomicElementType("g1", m2, 1.0);
    initializeGenomicElement(g1, 0, L - 1);

    initializeMutationRate(MU_DELETERIOUS);
    initializeRecombinationRate(REC_RATE);
}

// Load burn-in state
1 early() {

    sim.readFromPopulationFile(
        "burnin_state_K=5000_simID=3574899238261820451.txt"
    );

    // Offset RNG for replicate independence
    setSeed(getSeed() + jobID);
    defineConstant("repID", getSeed());

    defineConstant("START_GEN", sim.generation);

    catn("Phase 2 (WF): Replicate " + jobID);
    catn("Loaded burn-in state at generation " + START_GEN);
}

// Introduce inversion exactly once
1 late() {

    if (sim.generation == START_GEN) {

        p1.sampleIndividuals(1)
          .haplosomes[0]
          .addNewDrawnMutation(m3, INV_MARKER_POS);

        inv_freq = sum(
            p1.individuals.haplosomes
              .countOfMutationsOfType(m3)
        ) / (2.0 * p1.individualCount);

        catn("Generation " + sim.generation +
             ": Inversion introduced. Frequency = " + inv_freq);
    }
}

// Recombination suppression in heterozygotes
recombination() {

    if (haplosome1.containsMarkerMutation(m3, INV_MARKER_POS) ==
        haplosome2.containsMarkerMutation(m3, INV_MARKER_POS))
        return F;

    inInv = (breakpoints > INV_START) & (breakpoints < INV_END);
    if (!any(inInv))
        return F;

    breakpoints = breakpoints[!inInv];
    return T;
}

// Tracking inversion fate
1: late() {

    gensSinceIntro = sim.generation - START_GEN;
    if (gensSinceIntro < 0)
        return;

    inv_count = sum(
        p1.individuals.haplosomes
          .countOfMutationsOfType(m3)
    );
    inv_freq = inv_count / (2.0 * p1.individualCount);

    // Loss
    if (inv_freq == 0.0) {
        catn("Generation " + gensSinceIntro +
             ": Inversion LOST (replicate " + jobID + ")");
        sim.simulationFinished();
    }

    // Fixation
    if (inv_freq >= 0.99) {
        catn("Generation " + gensSinceIntro +
             ": Inversion FIXED (replicate " + jobID + ")");
        sim.simulationFinished();
    }

    // Periodic logging
    if (gensSinceIntro >= 1000 &
        gensSinceIntro % LOG_INTERVAL == 0) {

        numSTD = 0;
        numHET = 0;
        numINV = 0;

        for (ind in p1.individuals) {
            invCopies = sum(
                ind.haplosomes.countOfMutationsOfType(m3)
            );
            if (invCopies == 0) numSTD = numSTD + 1;
            else if (invCopies == 1) numHET = numHET + 1;
            else numINV = numINV + 1;
        }

        catn("Gen " + gensSinceIntro +
             " | Job " + jobID +
             " | Inv freq: " + inv_freq +
             " | STD: " + numSTD +
             " HET: " + numHET +
             " INV: " + numINV);
    }

    // End of tracking window
    if (gensSinceIntro == INV_TRACKING_GENS) {

        if (inv_freq > 0.0 & inv_freq < 0.99) {

            catn("SUCCESS: Replicate " + jobID +
                 " maintained polymorphism");
            catn("Final inversion frequency: " + inv_freq);

            outfile = "inversion_polymorphic_job=" + jobID +
                      "_rep=" + repID +
                      "_freq=" + inv_freq + ".txt";

            sim.outputFull(outfile);
            catn("Saved: " + outfile);
        }
        else {
            catn("Replicate " + jobID +
                 " did not maintain polymorphism (freq=" +
                 inv_freq + ")");
        }

        sim.simulationFinished();
    }
}
